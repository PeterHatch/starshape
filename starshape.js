// Generated by CoffeeScript 1.10.0
(function() {
  var $controlAngle, $controlDistance, $controlPercentage, $innerRadius, $straightPercentage, addPoints, calculateAngle, calculateControlPoints, calculateControlPointsFromIntermediate, calculateDistance, calculateInnerPoints, calculateIntermediatePoints, calculateIntermediatePointsComingAndGoing, calculateLineToCurveTransitionPoints, calculateOuterPoints, calculateRadius, calculateSimpleIntermediatePoints, crossingCubicPoints, drawCrossingCubicStar, drawCubicStar, drawLinearStar, drawQuadraticStar, drawStarFunction, drawStarWithCircularTips, drawStarWithCubicTips, drawStarWithQuadraticTips, initializeOptions, innerPointStrings, outerAngles, outerPointStrings, pointAsString, polarToCartesian, refreshBackground, refreshForeground, refreshStarPath, setShapeToCircular, setShapeToCrossingCubic, setShapeToCubic, setShapeToQuadratic, updateSlider, updateUrlQuery, uri;

  $innerRadius = null;

  $straightPercentage = null;

  $controlPercentage = null;

  $controlAngle = null;

  $controlDistance = null;

  drawStarFunction = null;

  uri = null;

  refreshForeground = function(color) {
    return $("#swatch").css("color", color.toHexString());
  };

  refreshBackground = function(color) {
    if (color != null) {
      return $("#swatch").css("background-color", color.toHexString());
    } else {
      return $("#swatch").css("background-color", "");
    }
  };

  setShapeToCircular = function() {
    drawStarFunction = drawStarWithCircularTips;
    $("#inner-radius-section").css("visibility", "visible");
    $("#straight-percentage-section").css("visibility", "visible");
    $("#control-point-section").css("visibility", "collapse");
    $("#control-point-angle-section").css("visibility", "collapse");
    $("#control-point-distance-section").css("visibility", "collapse");
    updateUrlQuery("s", "circular");
    return refreshStarPath();
  };

  setShapeToQuadratic = function() {
    drawStarFunction = drawStarWithQuadraticTips;
    $("#inner-radius-section").css("visibility", "visible");
    $("#straight-percentage-section").css("visibility", "visible");
    $("#control-point-section").css("visibility", "collapse");
    $("#control-point-angle-section").css("visibility", "collapse");
    $("#control-point-distance-section").css("visibility", "collapse");
    updateUrlQuery("s", "quadratic");
    return refreshStarPath();
  };

  setShapeToCubic = function() {
    drawStarFunction = drawStarWithCubicTips;
    $("#inner-radius-section").css("visibility", "visible");
    $("#straight-percentage-section").css("visibility", "visible");
    $("#control-point-section").css("visibility", "visible");
    $("#control-point-angle-section").css("visibility", "collapse");
    $("#control-point-distance-section").css("visibility", "collapse");
    updateUrlQuery("s", "cubic");
    return refreshStarPath();
  };

  setShapeToCrossingCubic = function() {
    drawStarFunction = drawCrossingCubicStar;
    $("#inner-radius-section").css("visibility", "collapse");
    $("#straight-percentage-section").css("visibility", "collapse");
    $("#control-point-section").css("visibility", "collapse");
    $("#control-point-angle-section").css("visibility", "visible");
    $("#control-point-distance-section").css("visibility", "visible");
    updateUrlQuery("s", "crossingcubic");
    return refreshStarPath();
  };

  refreshStarPath = function() {
    if ($straightPercentage.val() === "100") {
      return drawLinearStar();
    } else {
      return drawStarFunction();
    }
  };

  updateSlider = function(sliderElement, value) {
    $(".rangeslider__handle", sliderElement.$range).text(value);
    return refreshStarPath();
  };

  updateUrlQuery = function(key, value) {
    uri.search(function(queryParams) {
      queryParams[key] = value;
    });
    return history.replaceState(null, "", uri.resource());
  };

  initializeOptions = function() {
    var options;
    uri = new URI();
    options = uri.search(true);
    if (options.s == null) {
      options.s = "crossingcubic";
    }
    if (options.r == null) {
      options.r = 1 - (2 / (1 + Math.sqrt(5)));
    }
    if (options.l == null) {
      options.l = 75;
    }
    if (options.c == null) {
      options.c = 100;
    }
    if (options.ca == null) {
      options.ca = 180;
    }
    if (options.cd == null) {
      options.cd = 0.14;
    }
    if (options.fg == null) {
      options.fg = "fddc34";
    }
    if (options.bg === void 0) {
      options.bg = "000000";
    }
    return options;
  };

  $(document).ready(function() {
    var options;
    options = initializeOptions();
    $innerRadius = $("#inner-radius");
    $straightPercentage = $("#straight-percentage");
    $controlPercentage = $("#control-percentage");
    $controlAngle = $("#control-angle");
    $controlDistance = $("#control-distance");
    $("#circular").change(setShapeToCircular);
    $("#quadratic").change(setShapeToQuadratic);
    $("#cubic").change(setShapeToCubic);
    $("#crossingcubic").change(setShapeToCrossingCubic);
    $("#" + options.s).prop("checked", true);
    $("input[name=shape]:checked").change();
    $("#fg-color-picker").spectrum({
      showInput: true,
      color: options.fg,
      move: refreshForeground,
      hide: refreshForeground,
      change: function(color) {
        return updateUrlQuery("fg", color.toHex());
      }
    });
    $("#bg-color-picker").spectrum({
      showInput: true,
      color: options.bg,
      allowEmpty: true,
      move: refreshBackground,
      hide: refreshBackground,
      change: function(color) {
        return updateUrlQuery("bg", color !== null ? color.toHex() : null);
      }
    });
    refreshForeground($("#fg-color-picker").spectrum("get"));
    refreshBackground($("#bg-color-picker").spectrum("get"));
    $innerRadius.rangeslider({
      polyfill: false,
      onSlide: function(_, value) {
        return updateSlider(this, value);
      },
      onSlideEnd: function(_, value) {
        return updateUrlQuery("r", value);
      }
    });
    $innerRadius.val(options.r).change();
    $straightPercentage.rangeslider({
      polyfill: false,
      onSlide: function(_, value) {
        return updateSlider(this, value + "%");
      },
      onSlideEnd: function(_, value) {
        return updateUrlQuery("l", value);
      }
    });
    $straightPercentage.val(options.l).change();
    $controlPercentage.rangeslider({
      polyfill: false,
      onSlide: function(_, value) {
        return updateSlider(this, value + "%");
      },
      onSlideEnd: function(_, value) {
        return updateUrlQuery("c", value);
      }
    });
    $controlPercentage.val(options.c).change();
    $controlAngle.rangeslider({
      polyfill: false,
      onSlide: function(_, value) {
        return updateSlider(this, value);
      },
      onSlideEnd: function(_, value) {
        return updateUrlQuery("ca", value);
      }
    });
    $controlAngle.val(options.ca).change();
    $controlDistance.rangeslider({
      polyfill: false,
      onSlide: function(_, value) {
        return updateSlider(this, value);
      },
      onSlideEnd: function(_, value) {
        return updateUrlQuery("cd", value);
      }
    });
    return $controlDistance.val(options.cd).change();
  });

  polarToCartesian = function(angle, distance) {
    var x, y;
    x = Math.cos(angle) * distance;
    y = Math.sin(angle) * distance;
    return {
      x: x,
      y: y
    };
  };

  pointAsString = function(point) {
    return "" + point.x + "," + point.y;
  };

  addPoints = function(arg) {
    var point1, point2;
    point1 = arg[0], point2 = arg[1];
    return {
      x: point1.x + point2.x,
      y: point1.y + point2.y
    };
  };

  calculateDistance = function(point1, point2) {
    return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
  };

  calculateAngle = function(point1, point2) {
    return Math.atan2(point2.y - point1.y, point2.x - point1.x);
  };

  calculateRadius = function(a, b, c) {
    var angle_cab, angle_cax, length_am;
    angle_cab = calculateAngle(a, b);
    angle_cax = angle_cab + (Math.PI / 2);
    length_am = calculateDistance(a, c) / 2;
    return length_am * (1 / Math.cos(angle_cax));
  };

  calculateInnerPoints = function() {
    var innerAngles, innerRadius;
    innerRadius = $innerRadius.val();
    innerAngles = [-7 * Math.PI / 10, -3 * Math.PI / 10, Math.PI / 10, 5 * Math.PI / 10, 9 * Math.PI / 10];
    return innerAngles.map(function(angle) {
      return polarToCartesian(angle, innerRadius);
    });
  };

  innerPointStrings = function() {
    return calculateInnerPoints().map(pointAsString);
  };

  outerAngles = function() {
    return [-5 * Math.PI / 10, -Math.PI / 10, 3 * Math.PI / 10, 7 * Math.PI / 10, -9 * Math.PI / 10];
  };

  calculateOuterPoints = function(radius) {
    if (radius == null) {
      radius = 1;
    }
    return outerAngles().map(function(angle) {
      return polarToCartesian(angle, radius);
    });
  };

  outerPointStrings = function(radius) {
    if (radius == null) {
      radius = 1;
    }
    return calculateOuterPoints(radius).map(pointAsString);
  };

  calculateSimpleIntermediatePoints = function(innerPoints, outerPoints, percentage) {
    var angles, displacementVectors, fullDistance, straightDistance;
    fullDistance = calculateDistance(innerPoints[0], outerPoints[0]);
    straightDistance = (percentage / 100) * fullDistance;
    angles = _.zip(innerPoints, outerPoints).map(function(arg) {
      var innerPoint, outerPoint;
      innerPoint = arg[0], outerPoint = arg[1];
      return calculateAngle(innerPoint, outerPoint);
    });
    displacementVectors = angles.map(function(angle) {
      return polarToCartesian(angle, straightDistance);
    });
    return _.zip(innerPoints, displacementVectors).map(addPoints);
  };

  calculateIntermediatePoints = function(innerPoints1, innerPoints2, outerPoints, percentage) {
    var points1, points2;
    points1 = calculateSimpleIntermediatePoints(innerPoints1, outerPoints, percentage);
    points2 = calculateSimpleIntermediatePoints(innerPoints2, outerPoints, percentage);
    return [points1, points2];
  };

  calculateIntermediatePointsComingAndGoing = function(innerPoints, outerPoints, percentage) {
    var shiftedInnerPoints;
    shiftedInnerPoints = innerPoints.slice(1);
    shiftedInnerPoints.push(innerPoints[0]);
    return calculateIntermediatePoints(innerPoints, shiftedInnerPoints, outerPoints, percentage);
  };

  calculateLineToCurveTransitionPoints = function(innerPoints, outerPoints) {
    var percentage;
    percentage = $straightPercentage.val();
    return calculateIntermediatePointsComingAndGoing(innerPoints, outerPoints, percentage);
  };

  calculateControlPoints = function(innerPoints, outerPoints) {
    var percentage;
    percentage = $controlPercentage.val();
    return calculateIntermediatePointsComingAndGoing(innerPoints, outerPoints, percentage);
  };

  calculateControlPointsFromIntermediate = function(intermediatePoints1, intermediatePoints2, outerPoints) {
    var percentage;
    percentage = $controlPercentage.val();
    return calculateIntermediatePoints(intermediatePoints1, intermediatePoints2, outerPoints, percentage);
  };

  crossingCubicPoints = function() {
    var angles, controlAngle, controlAngles1, controlAngles2, controlDistance, controlPoints1, controlPoints2, displacement1, displacement2, outerPoints;
    outerPoints = calculateOuterPoints();
    controlAngle = $controlAngle.val();
    controlDistance = $controlDistance.val();
    controlAngle = (controlAngle / 2) * (Math.PI / 180);
    angles = outerAngles();
    controlAngles1 = angles.map(function(angle) {
      return angle + Math.PI - controlAngle;
    });
    controlAngles2 = angles.map(function(angle) {
      return angle + Math.PI + controlAngle;
    });
    displacement1 = controlAngles1.map(function(angle) {
      return polarToCartesian(angle, controlDistance);
    });
    displacement2 = controlAngles2.map(function(angle) {
      return polarToCartesian(angle, controlDistance);
    });
    controlPoints1 = _.zip(outerPoints, displacement1).map(addPoints);
    controlPoints2 = _.zip(outerPoints, displacement2).map(addPoints);
    return [outerPoints.map(pointAsString), controlPoints1.map(pointAsString), controlPoints2.map(pointAsString)];
  };

  drawLinearStar = function() {
    var innerPoints, outerPoints, pathString, points;
    innerPoints = innerPointStrings();
    outerPoints = outerPointStrings();
    points = _.flatten(_.zip(innerPoints, outerPoints));
    pathString = "M " + points.shift() + " L ";
    pathString += points.join(" ");
    pathString += " Z";
    return $("#star").attr("d", pathString);
  };

  drawQuadraticStar = function() {
    var firstPoint, innerPoints, outerPoints, pathString, points, sectionStrings;
    innerPoints = innerPointStrings();
    outerPoints = outerPointStrings();
    firstPoint = innerPoints[0];
    innerPoints.push(innerPoints.shift());
    points = _.zip(outerPoints, innerPoints);
    sectionStrings = points.map(function(arg) {
      var innerPoint, outerPoint;
      outerPoint = arg[0], innerPoint = arg[1];
      return " Q " + outerPoint + " " + innerPoint;
    });
    pathString = "M " + firstPoint + sectionStrings.join('') + " Z";
    return $("#star").attr("d", pathString);
  };

  drawCubicStar = function() {
    var controlPoints1, controlPoints2, firstPoint, innerPoints, outerPoints, pathString, points, ref, sectionStrings;
    innerPoints = calculateInnerPoints();
    outerPoints = calculateOuterPoints();
    ref = calculateControlPoints(innerPoints, outerPoints), controlPoints1 = ref[0], controlPoints2 = ref[1];
    firstPoint = pointAsString(innerPoints[0]);
    innerPoints.push(innerPoints.shift());
    points = _.zip(controlPoints1.map(pointAsString), controlPoints2.map(pointAsString), innerPoints.map(pointAsString));
    sectionStrings = points.map(function(arg) {
      var control1, control2, inner;
      control1 = arg[0], control2 = arg[1], inner = arg[2];
      return "C " + control1 + " " + control2 + " " + inner;
    });
    pathString = ("M " + firstPoint + " ") + sectionStrings.join(" ") + " Z";
    return $("#star").attr("d", pathString);
  };

  drawStarWithCircularTips = function() {
    var innerPoints, intermediatePoints1, intermediatePoints2, outerPoints, pathString, points, radius, ref, sectionStrings;
    innerPoints = calculateInnerPoints();
    outerPoints = calculateOuterPoints();
    ref = calculateLineToCurveTransitionPoints(innerPoints, outerPoints), intermediatePoints1 = ref[0], intermediatePoints2 = ref[1];
    radius = calculateRadius(intermediatePoints1[0], outerPoints[0], intermediatePoints2[0]);
    points = _.zip(innerPoints.map(pointAsString), intermediatePoints1.map(pointAsString), intermediatePoints2.map(pointAsString));
    sectionStrings = points.map(function(arg) {
      var inner, intermediate1, intermediate2;
      inner = arg[0], intermediate1 = arg[1], intermediate2 = arg[2];
      return inner + " L " + intermediate1 + " A " + radius + " " + radius + " 0 0 1 " + intermediate2;
    });
    pathString = "M " + sectionStrings.join(" L ") + " Z";
    return $("#star").attr("d", pathString);
  };

  drawStarWithQuadraticTips = function() {
    var innerPoints, intermediatePoints1, intermediatePoints2, outerPoints, pathString, points, ref, sectionStrings;
    if ($straightPercentage.val() === "0") {
      drawQuadraticStar();
      return;
    }
    innerPoints = calculateInnerPoints();
    outerPoints = calculateOuterPoints();
    ref = calculateLineToCurveTransitionPoints(innerPoints, outerPoints), intermediatePoints1 = ref[0], intermediatePoints2 = ref[1];
    points = _.zip(innerPoints.map(pointAsString), intermediatePoints1.map(pointAsString), outerPoints.map(pointAsString), intermediatePoints2.map(pointAsString));
    sectionStrings = points.map(function(arg) {
      var inner, intermediate1, intermediate2, outer;
      inner = arg[0], intermediate1 = arg[1], outer = arg[2], intermediate2 = arg[3];
      return inner + " L " + intermediate1 + " Q " + outer + " " + intermediate2;
    });
    pathString = "M " + sectionStrings.join(" L ") + " Z";
    return $("#star").attr("d", pathString);
  };

  drawStarWithCubicTips = function() {
    var controlPoints1, controlPoints2, innerPoints, intermediatePoints1, intermediatePoints2, outerPoints, pathString, points, ref, ref1, sectionStrings;
    if ($straightPercentage.val() === "0") {
      drawCubicStar();
      return;
    }
    innerPoints = calculateInnerPoints();
    outerPoints = calculateOuterPoints();
    ref = calculateLineToCurveTransitionPoints(innerPoints, outerPoints), intermediatePoints1 = ref[0], intermediatePoints2 = ref[1];
    ref1 = calculateControlPointsFromIntermediate(intermediatePoints1, intermediatePoints2, outerPoints), controlPoints1 = ref1[0], controlPoints2 = ref1[1];
    points = _.zip(innerPoints.map(pointAsString), intermediatePoints1.map(pointAsString), controlPoints1.map(pointAsString), controlPoints2.map(pointAsString), intermediatePoints2.map(pointAsString));
    sectionStrings = points.map(function(arg) {
      var control1, control2, inner, intermediate1, intermediate2;
      inner = arg[0], intermediate1 = arg[1], control1 = arg[2], control2 = arg[3], intermediate2 = arg[4];
      return inner + " L " + intermediate1 + " C " + control1 + " " + control2 + " " + intermediate2;
    });
    pathString = "M " + sectionStrings.join(" L ") + " Z";
    return $("#star").attr("d", pathString);
  };

  drawCrossingCubicStar = function() {
    var control1, control2, outer, pathString, ref;
    ref = crossingCubicPoints(), outer = ref[0], control1 = ref[1], control2 = ref[2];
    pathString = "M " + outer[0] + " C " + control1[0] + " " + control2[2] + " " + outer[2] + " C " + control1[2] + " " + control2[4] + " " + outer[4] + " C " + control1[4] + " " + control2[1] + " " + outer[1] + " C " + control1[1] + " " + control2[3] + " " + outer[3] + " C " + control1[3] + " " + control2[0] + " " + outer[0] + " Z";
    return $("#star").attr("d", pathString);
  };

}).call(this);

//# sourceMappingURL=starshape.js.map
